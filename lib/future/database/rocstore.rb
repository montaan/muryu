
module Future

have_rocstore = begin
  require 'rocstore'
  true
rescue LoadError
  false
end

if have_rocstore
  module ROCStoreIntegration
    KNOWN_COLUMNS = %w[
      deleted image_index mimetype_id size
    ].inject({}){|s,x| s[x] = x; s}
    KNOWN_CRITERIA = %w[
      owner.name deleted groups mimetype_id size path
    ].inject({}){|s,x| s[x] = x; s}
    KNOWN_ORDERS = %w[
      image_index mimetype_id size deleted
    ]

    COLUMNS = {
      :image_index => "items.image_index",
      :deleted     => "items.deleted",
      :mimetype_id => "items.mimetype_id",
      :size        => "items.size",
      :path        => "items.path"
    }

    module DB
      include ROCStore
      # TODO: conf the env somewhere
      DBPATH = "/path/to/rocstore/db/dir"

      # plain ugly; should read a schema desc dumped by the tuplemover instead
      # of reading anything it can find on disk
      module Reader
        extend self

        ACCESS = {:int => AccessInt, :string => AccessString, :float => AccessFloat}
        def indexed_access(type, base)
          ACCESS[type].new_with_value_index(base + ".dat",
                                            base + ".pidx",
                                            base + ".vidx")
        end

        def access(type, base)
          ACCESS[type].new(base + ".dat", base + ".pidx")
        end

        def access_methods(names, types)
          ret = {}
          colname = lambda{|x| x[/[^-]*$/].to_s}
          ret[colname[names.first]] = indexed_access(types.first, names.first)
          names[1..-1].zip(types[1..-1]).each do |name, type|
            ret[colname[name]] = access(type, name)
          end
          ret
        end

        def table(name, orders, order_types, columns, types)
          ret = {}
          orders.zip(order_types).each do |order, type|
            # puts "ORDER #{order}"
            cols = [[order, type]] | columns.zip(types)
            file_prefixes = cols.map{|col, _| File.join(DBPATH, "#{name}-#{order}-#{col}") }

            existent = file_prefixes.zip(cols).select{|f, _| File.exist?(f + ".dat") }

            file_prefixes = existent.map{|f, _| f}
            cols = existent.map{|_, c| c}

            # puts "ACCESS #{file_prefixes.inspect} #{cols.map{|_,t|t}.inspect}"
            ret[order] = access_methods(file_prefixes, cols.map{|_, t| t})

            Dir["#{DBPATH}/#{name}-*-jindex.dat"].each do |page_file|
              pidx_file = page_file.sub(/dat$/, "pidx")
              idxname = /#{name}-(.+)-jindex\.dat$/.match(page_file).captures
              ret["JI-#{idxname}"] = AccessInt.new(page_file, pidx_file)
            end
          end
          ret
        end
      end # Reader

      # the plan is to have this generated by the tuplemover, for the time
      # being defined manually
      Items = Reader.table("items",
                     %w[items.deleted items.image_index items.mimetype_id
                 users.name items.size],
                 [:int, :int, :int, :string, :int],
                 %w[items.image_index items.mimetype_id items.deleted items.path
                 items.size],
                 [:int, :int, :int, :string, :int])
      GroupsItems = Reader.table("groups",
                                 %w[groups.id], [:int],
                                 %w[groups.id], [:int])
    end # DB


    def self.can_handle?(query)
      unless query[:colums].all?{|c| KNOWN_COLUMNS.include?(c)} &&
             query.keys.all?{|k| KNOWN_CRITERIA.include?(k)} &&
             query[:order_by].size == 1 &&
             query[:order_by].each{|field, dir| KNOWN_ORDERS.include?(field)}
        return false
      end
      true
    end

    def self.rfind_all(user, query)
      h = query.dup
      # taken from access_control; refactor or keep in sync
      h["groups"] = [h["groups"]] if h["groups"] and not h["groups"][0].is_a? Array
      h["groups"] ||= []
      h["groups"] << user.groups

      case order = h[:order_by][0]
      when "image_index", "mimetype_id", "size", "deleted";
        projection = "items.#{order}"
      else
        # TODO: other orders
        projection = "items.image_index"
      end

      group_ids = ROCStore::StreamInt.literal(h["groups"].sort, true)
      pos1 = DB::GroupsItems["groups.id"]["groups.id"].pos_stream(group_ids)
      pos2 = DB::Items["JI-groups.id-#{projection}"].pos_filtered(pos1)
      pos = ROCStore::PosStream.new_from_join_index(pos2).sort

      if user_name = h["owner.name"]
        p1 = DB::Items["users.name"]["users.name"].value_filtered([:Eq, user_name])
        p2 = DB::Items["JI-users.name-#{projection}"].pos_filtered(p1.to_pos_stream)
        pos = pos.and(p2)
      end

      if size_criterion = h["size"]
        # TODO; still not handled by
        # MuryuDispatch::Items.parse_search_query
      end

      if mimetype_ids = h["mimetype_ids"]
        # select, normally faster anyway for low selectivities
        # TODO: criterion missing in the extension, add it and enable this
        # p1 = DB::Items[projection]["items.mimetype_id"].stream.
               # filter([:EqAny, mimetype_ids]).to_pos_stream
        # pos = pos.and(p1)
        # query through join index
        mimetypes = ROCStore::StreamInt.literal(mimetype_ids.sort, true)
        p1 = DB::Items["items.mimetype_id"]["items.mimetype_id"].pos_stream(mimetypes)
        p2 = DB::Items["JI-items.mimetype_id-#{projection}"].pos_filtered(p1)
        pos = pos.and(ROCStore::PosStream.new_from_join_index(p2))
      end

      # ...

      if path_criteria = h[:path]
        case path_criteria.predicate
          # TODO
        when "ALL";
        when "NOT ALL";
        when "ANY"
          regexps = path_criteria.map do |r|
            # FIXME: cheap hack, why are these regexps anyway
            txt = r.inspect[%r{/(.)/(i?)}, 1]
          end
          p1 = DB::Items[projection]["items.path"].stream.grep(regexps.join("|"))
          pos = pos.and(p1.to_pos_stream)
        end
      end

      pos = pos.memoize

      ret = {}
      h[:colums].each do |c|
        ret[c] = DB::Items[projection][COLUMNS[c]].pos_filtered(pos.dup)
      end

      ret.each{|c| c.reverse!} if h[:order_by][1] == :desc

      ret
    end # rfind_all

  end # ROCStoreIntegration
end # if have_rocstore

end # Future
